/*
Copyright (c) 2021 TriggerMesh Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package gitlabsqs

import (
	"context"
	"encoding/json"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/dynamic"
	clientset "k8s.io/client-go/kubernetes"

	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/sqs"
	"github.com/aws/aws-sdk-go/service/sqs/sqsiface"

	gitlab "github.com/xanzy/go-gitlab"

	"github.com/triggermesh/test-infra/test/e2e/framework"
	e2esqs "github.com/triggermesh/test-infra/test/e2e/framework/aws/sqs"
	"github.com/triggermesh/test-infra/test/e2e/framework/bridges"
	"github.com/triggermesh/test-infra/test/e2e/framework/ducktypes"
	e2egitlab "github.com/triggermesh/test-infra/test/e2e/framework/gitlab"
	"github.com/triggermesh/test-infra/test/e2e/framework/manifest"
)

/* This test suite requires:

- A GitLab OAuth2 access token exported in the environment as GITLAB_API_TOKEN, with the "api" OAuth scope
- AWS credentials in whichever form (https://docs.aws.amazon.com/sdk-for-go/api/aws/session/#hdr-Sessions_options_from_Shared_Config)
- The name of an AWS region exported in the environment as AWS_REGION
*/

var bridgeAPIVersion = schema.GroupVersion{
	Group:   "flow.triggermesh.io",
	Version: "v1alpha1",
}

const bridgeResource = "bridges"

const gitlabApiTokenSecretKey = "api_token"
const gitlabWebhookSecretKey = "webhook_secret"

const awsAccessKeyIDSecretKey = "access_key_id"
const awsSecretAccessKeySecretKey = "secret_access_key"

var _ = Describe("GitLab to SQS", func() {
	f := framework.New("gitlab-sqs")

	var gitlabClient *gitlab.Client
	var gitlabProject *gitlab.Project

	var sqsClient sqsiface.SQSAPI
	var sqsQueueURL string

	BeforeEach(func() {
		var brdgClient dynamic.ResourceInterface
		var gitlabSecret *corev1.Secret
		var awsSecret *corev1.Secret

		ns := f.UniqueName

		gvr := bridgeAPIVersion.WithResource(bridgeResource)
		brdgClient = f.DynamicClient.Resource(gvr).Namespace(ns)

		gitlabClient = e2egitlab.NewClient()

		sess := session.Must(session.NewSession())
		sqsClient = sqs.New(sess)

		By("creating a GitLab project", func() {
			gitlabProject = e2egitlab.CreateProject(gitlabClient, f)
		})

		By("creating a SQS queue", func() {
			sqsQueueURL = e2esqs.CreateQueue(sqsClient, f)
		})

		By("creating a Kubernetes Secret containing the GitLab API token", func() {
			gitlabSecret = createAPITokenSecret(f.KubeClient, ns, gitlabApiTokenSecretKey, e2egitlab.APIToken())
		})

		By("creating a Kubernetes Secret containing the AWS Access Credentials", func() {
			awsSecret = createAWSCredsSecret(f.KubeClient, ns, readAWSCredentials(sess))
		})

		By("creating a Bridge object", func() {
			brdgTmpl := manifest.ObjectFromFile("bridges/manifests/gitlab-sqs-bridge.yaml")

			brdg, err := bridges.CreateBridge(brdgClient, brdgTmpl, ns, "test-",
				withProject(gitlabProject.WebURL),
				withAPITokenSecret(gitlabSecret.Name, gitlabApiTokenSecretKey),
				withARN(e2esqs.QueueARN(sqsClient, sqsQueueURL)),
				withAWSCredsSecret(awsSecret.Name),
			)
			Expect(err).ToNot(HaveOccurred())

			ducktypes.WaitUntilReady(f.DynamicClient, brdg)
		})
	})

	AfterEach(func() {
		By("deleting GitLab project "+gitlabProject.Name, func() {
			e2egitlab.DeleteProject(gitlabClient, gitlabProject)
		})

		By("deleting SQS queue "+sqsQueueURL, func() {
			e2esqs.DeleteQueue(sqsClient, sqsQueueURL)
		})
	})

	It("receives events generated by the source", func() {
		var file *gitlab.File
		var receivedMsg []byte

		By("creating a Git commit", func() {
			file = e2egitlab.CreateCommit(gitlabClient, gitlabProject)
		})

		By("polling the SQS queue", func() {
			var receivedMsgs []*sqs.Message

			receivedMsgs = e2esqs.ReceiveMessages(sqsClient, sqsQueueURL)

			Expect(receivedMsgs).To(HaveLen(1),
				"Received %d messages instead of 1", len(receivedMsgs))

			receivedMsg = []byte(*receivedMsgs[0].Body)
		})

		By("inspecting the message payload", func() {
			msgData := make(map[string]interface{})
			err := json.Unmarshal(receivedMsg, &msgData)
			Expect(err).ToNot(HaveOccurred())

			Expect(msgData["type"]).To(Equal("dev.knative.sources.gitlab.push"))

			eventData, err := json.Marshal(msgData["data"])
			Expect(err).ToNot(HaveOccurred())

			gitlabEvent := &gitlab.PushEvent{}
			err = json.Unmarshal(eventData, gitlabEvent)
			Expect(err).ToNot(HaveOccurred())

			Expect(gitlabEvent.ProjectID).To(Equal(gitlabProject.ID))
			Expect(gitlabEvent.TotalCommitsCount).To(Equal(1))
			Expect(gitlabEvent.Commits[0].ID).To(Equal(file.CommitID))
		})
	})
})

// withProject sets the projectUrl spec field of the GitLabSource.
func withProject(projectUrl string) bridges.BridgeOption {
	return func(bridge *unstructured.Unstructured) {
		components := bridges.Components(bridge)
		src := components[bridges.SeekComponentByKind(components, "GitLabSource")]

		if err := unstructured.SetNestedField(src, projectUrl, "object", "spec", "projectUrl"); err != nil {
			framework.FailfWithOffset(2, "Failed to set object.spec.projectUrl")
		}

		bridges.SetComponents(bridge, components)
	}
}

// withAPITokenSecret sets the accessToken and secretToken spec fields of the GitLabSource.
func withAPITokenSecret(secretName, tokenKey string) bridges.BridgeOption {
	return func(brdg *unstructured.Unstructured) {
		comps := bridges.Components(brdg)
		gitlabSrc := comps[bridges.SeekComponentByKind(comps, "GitLabSource")]

		tokenSecretRef := map[string]interface{}{
			"secretKeyRef": map[string]interface{}{
				"name": secretName,
				"key":  tokenKey,
			},
		}

		webhookSecretRef := map[string]interface{}{
			"secretKeyRef": map[string]interface{}{
				"name": secretName,
				"key":  gitlabWebhookSecretKey,
			},
		}

		if err := unstructured.SetNestedMap(gitlabSrc, tokenSecretRef, "object", "spec", "accessToken"); err != nil {
			framework.FailfWithOffset(2, "Failed to set spec.accessToken field: %s", err)
		}
		if err := unstructured.SetNestedMap(gitlabSrc, webhookSecretRef, "object", "spec", "secretToken"); err != nil {
			framework.FailfWithOffset(2, "Failed to set spec.secretToken field: %s", err)
		}

		// "comps" is a deep copy returned by unstructured.NestedSlice,
		// so we need set the modified version on the Bridge object
		bridges.SetComponents(brdg, comps)
	}
}

// withARN sets the arn spec field of the AWSSQSTarget.
func withARN(arn string) bridges.BridgeOption {
	return func(brdg *unstructured.Unstructured) {
		comps := bridges.Components(brdg)
		sqsTarget := comps[bridges.SeekComponentByKind(comps, "AWSSQSTarget")]

		if err := unstructured.SetNestedField(sqsTarget, arn, "object", "spec", "arn"); err != nil {
			framework.FailfWithOffset(2, "Failed to set spec.arn field: %s", err)
		}

		// "comps" is a deep copy returned by unstructured.NestedSlice,
		// so we need set the modified version on the Bridge object
		bridges.SetComponents(brdg, comps)
	}
}

// withAWSCredsSecret sets the awsApiKey and awsApiSecret spec fields of the AWSSQSTarget.
func withAWSCredsSecret(secretName string) bridges.BridgeOption {
	return func(brdg *unstructured.Unstructured) {
		comps := bridges.Components(brdg)
		sqsTarget := comps[bridges.SeekComponentByKind(comps, "AWSSQSTarget")]

		apiKeySecretRef := map[string]interface{}{
			"secretKeyRef": map[string]interface{}{
				"name": secretName,
				"key":  awsAccessKeyIDSecretKey,
			},
		}

		apiSecretSecretRef := map[string]interface{}{
			"secretKeyRef": map[string]interface{}{
				"name": secretName,
				"key":  awsSecretAccessKeySecretKey,
			},
		}

		if err := unstructured.SetNestedMap(sqsTarget, apiKeySecretRef, "object", "spec", "awsApiKey"); err != nil {
			framework.FailfWithOffset(2, "Failed to set spec.accessToken field: %s", err)
		}
		if err := unstructured.SetNestedMap(sqsTarget, apiSecretSecretRef, "object", "spec", "awsApiSecret"); err != nil {
			framework.FailfWithOffset(2, "Failed to set spec.secretToken field: %s", err)
		}

		// "comps" is a deep copy returned by unstructured.NestedSlice,
		// so we need set the modified version on the Bridge object
		bridges.SetComponents(brdg, comps)
	}
}

// createAPITokenSecret creates a Kubernetes Secret containing a GitLab API
// token and a hardcoded webhook token.
func createAPITokenSecret(c clientset.Interface, namespace, tokenKey, tokenVal string) *corev1.Secret {
	const webhookSecretVal = "test12345" // arbitrary value, to secure the webhook

	secr := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Namespace:    namespace,
			GenerateName: "gitlab-apitoken-",
		},
		StringData: map[string]string{
			tokenKey:               tokenVal,
			gitlabWebhookSecretKey: webhookSecretVal,
		},
	}

	var err error

	secr, err = c.CoreV1().Secrets(namespace).Create(context.Background(), secr, metav1.CreateOptions{})
	if err != nil {
		framework.FailfWithOffset(2, "Failed to create Secret: %s", err)
	}

	return secr
}

// TODO: These should be extracted out into a common location where they could be leveraged by all bridges

func readAWSCredentials(sess *session.Session) credentials.Value {
	creds, err := sess.Config.Credentials.Get()
	if err != nil {
		framework.FailfWithOffset(2, "Error reading AWS credentials: %s", err)
	}

	return creds
}

// createAWSCredsSecret creates a Kubernetes Secret containing a AWS credentials.
func createAWSCredsSecret(c clientset.Interface, namespace string, creds credentials.Value) *corev1.Secret {
	secr := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Namespace:    namespace,
			GenerateName: "aws-creds-",
		},
		StringData: map[string]string{
			awsAccessKeyIDSecretKey:     creds.AccessKeyID,
			awsSecretAccessKeySecretKey: creds.SecretAccessKey,
		},
	}

	var err error

	secr, err = c.CoreV1().Secrets(namespace).Create(context.Background(), secr, metav1.CreateOptions{})
	if err != nil {
		framework.FailfWithOffset(2, "Failed to create Secret: %s", err)
	}

	return secr
}
