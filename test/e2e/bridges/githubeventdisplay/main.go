/*
Copyright (c) 2020 TriggerMesh Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package githubeventdisplay

import (
	"context"
	"time"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/dynamic"
	clientset "k8s.io/client-go/kubernetes"

	"github.com/google/go-github/v32/github"

	cloudevents "github.com/cloudevents/sdk-go/v2"

	"github.com/triggermesh/test-infra/test/e2e/framework"
	"github.com/triggermesh/test-infra/test/e2e/framework/apps"
	"github.com/triggermesh/test-infra/test/e2e/framework/bridges"
	"github.com/triggermesh/test-infra/test/e2e/framework/ducktypes"
	e2egithub "github.com/triggermesh/test-infra/test/e2e/framework/github"
	"github.com/triggermesh/test-infra/test/e2e/framework/manifest"
)

/* This test suite requires:

- A GitHub OAuth2 access token exported in the environment as GITHUB_API_TOKEN, with the following OAuth scopes: [repo, delete_repo]
*/

var bridgeAPIVersion = schema.GroupVersion{
	Group:   "flow.triggermesh.io",
	Version: "v1alpha1",
}

const bridgeResource = "bridges"

const apiTokenSecretKey = "apiToken"

var _ = Describe("GitHub to Event-Display", func() {
	f := framework.New("github-eventdisplay")

	var ns string

	var ghClient *github.Client
	var repo *github.Repository

	var eventDisplayDeplName string
	var receivedEvents []cloudevents.Event

	BeforeEach(func() {
		var brdgClient dynamic.ResourceInterface
		var apiTokenSecret *corev1.Secret

		ns = f.UniqueName

		gvr := bridgeAPIVersion.WithResource(bridgeResource)
		brdgClient = f.DynamicClient.Resource(gvr).Namespace(ns)

		ghClient = e2egithub.NewClient()

		By("creating a GitHub repository", func() {
			repo = e2egithub.CreateRepository(ghClient, f)
		})

		By("creating a Kubernetes Secret containing the GitHub API token", func() {
			apiTokenSecret = createAPITokenSecret(f.KubeClient, ns, apiTokenSecretKey, e2egithub.APIToken())
		})

		By("creating a Bridge object", func() {
			brdgTmpl := manifest.ObjectFromFile("bridges/manifests/github-eventdisplay-bridge.yaml")

			brdg, err := createBridge(brdgClient, brdgTmpl, ns, "test-",
				withRepo(ownerAndRepo(repo)),
				withAPITokenSecret(apiTokenSecret.Name, apiTokenSecretKey),
			)
			Expect(err).ToNot(HaveOccurred())

			ducktypes.WaitUntilReady(f.DynamicClient, brdg)

			eventDisplayDeplName = bridges.EventDisplayDeploymentName(f.DynamicClient, ns)
		})
	})

	AfterEach(func() {

		By("deleting GitHub repository "+ownerAndRepo(repo), func() {
			e2egithub.DeleteRepository(ghClient, *repo.Owner.Login, *repo.Name)
		})
	})

	It("receives events generated by the source", func() {
		var commit *github.Commit

		By("checking whether the initial ping event was received", func() {
			// GitHub sends an initial ping event when the source gets created in order to check the
			// availability of the configured webhook. If the subscriber is already reporting "Ready" at the
			// time this event is sent, readReceivedEvents will return one result, which we need to discard
			// in subsequent assertions.

			readReceivedEvents(f.KubeClient, ns, eventDisplayDeplName, &receivedEvents)()

			Expect(receivedEvents).To(SatisfyAny(BeEmpty(), HaveLen(1)),
				"More than one event was received before the commit was even created")

			if len(receivedEvents) == 1 {
				e := receivedEvents[0]
				Expect(e.Type()).To(Equal("dev.knative.source.github.ping"))
				Expect(e.Source()).To(Equal(*repo.HTMLURL))

				framework.Logf("A ping event was received and will be ignored in the next assertions")
			}
		})

		By("creating a Git commit", func() {
			commit = e2egithub.CreateCommit(ghClient, *repo.Owner.Login, *repo.Name)
		})

		By("waiting for an event to be received", func() {
			const receiveTimeout = 10 * time.Second
			const pollInterval = 500 * time.Millisecond

			pingEventReceived := len(receivedEvents) > 0

			expectNumEvents := 1
			if pingEventReceived {
				expectNumEvents = 2
			}

			readReceivedEvents := readReceivedEvents(f.KubeClient, ns, eventDisplayDeplName, &receivedEvents)

			Eventually(readReceivedEvents, receiveTimeout, pollInterval).Should(HaveLen(expectNumEvents),
				"A push event should have been received")

			e := receivedEvents[len(receivedEvents)-1]
			Expect(e.Type()).To(Equal("dev.knative.source.github.push"))
			Expect(e.Source()).To(Equal(*repo.HTMLURL))
			Expect(e.Subject()).To(ContainSubstring((*commit.SHA)[:10]))
		})
	})
})

// ownerAndRepo returns a reference to a GitHub repository in the format
// "owner/repo".
func ownerAndRepo(r *github.Repository) string {
	return *r.Owner.Login + "/" + *r.Name
}

// createBridge creates a Bridge object initialized with the given options.
func createBridge(brdgCli dynamic.ResourceInterface, bridge *unstructured.Unstructured,
	namespace, namePrefix string, opts ...bridgeOption) (*unstructured.Unstructured, error) {

	bridge.SetNamespace(namespace)
	bridge.SetGenerateName(namePrefix)

	for _, opt := range opts {
		opt(bridge)
	}

	return brdgCli.Create(context.Background(), bridge, metav1.CreateOptions{})
}

type bridgeOption func(*unstructured.Unstructured)

// withRepo sets the ownerAndRepo spec field of the GitHubSource.
func withRepo(ownerAndRepo string) bridgeOption {
	return func(brdg *unstructured.Unstructured) {
		comps := bridges.Components(brdg)
		ghSrc := comps[bridges.SeekComponentByKind(comps, "GitHubSource")]

		if err := unstructured.SetNestedField(ghSrc, ownerAndRepo, "object", "spec", "ownerAndRepository"); err != nil {
			framework.FailfWithOffset(2, "Failed to set spec.ownerAndRepo field: %s", err)
		}

		// "comps" is a deep copy returned by unstructured.NestedSlice,
		// so we need set the modified version on the Bridge object
		bridges.SetComponents(brdg, comps)
	}
}

// withAPITokenSecret sets the accessToken and secretToken spec fields of the GitHubSource.
func withAPITokenSecret(secretName, apiTokenKey string) bridgeOption {
	return func(brdg *unstructured.Unstructured) {
		comps := bridges.Components(brdg)
		ghSrc := comps[bridges.SeekComponentByKind(comps, "GitHubSource")]

		tokenSecretRef := map[string]interface{}{
			"secretKeyRef": map[string]interface{}{
				"name": secretName,
				"key":  apiTokenKey,
			},
		}

		if err := unstructured.SetNestedMap(ghSrc, tokenSecretRef, "object", "spec", "accessToken"); err != nil {
			framework.FailfWithOffset(2, "Failed to set spec.accessToken field: %s", err)
		}
		if err := unstructured.SetNestedMap(ghSrc, tokenSecretRef, "object", "spec", "secretToken"); err != nil {
			framework.FailfWithOffset(2, "Failed to set spec.secretToken field: %s", err)
		}

		// "comps" is a deep copy returned by unstructured.NestedSlice,
		// so we need set the modified version on the Bridge object
		bridges.SetComponents(brdg, comps)
	}
}

// createAPITokenSecret creates a Kubernetes Secret containing a GitHub API token.
func createAPITokenSecret(c clientset.Interface, namespace, tokenKey, tokenVal string) *corev1.Secret {
	secr := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Namespace:    namespace,
			GenerateName: "gh-apitoken-",
		},
		StringData: map[string]string{
			tokenKey: tokenVal,
		},
	}

	var err error

	secr, err = c.CoreV1().Secrets(namespace).Create(context.Background(), secr, metav1.CreateOptions{})
	if err != nil {
		framework.FailfWithOffset(2, "Failed to create Secret: %s", err)
	}

	return secr
}

// readReceivedEvents returns a function that reads CloudEvents received by the
// event-display application and stores the result as the value of the given
// `receivedEvents` variable.
// The returned function signature satisfies the contract expected by
// gomega.Eventually: no argument and one or more return values.
func readReceivedEvents(c clientset.Interface, namespace, eventDisplayDeplName string,
	receivedEvents *[]cloudevents.Event) func() []cloudevents.Event {

	return func() []cloudevents.Event {
		ev := bridges.ReceivedEventDisplayEvents(
			apps.GetLogs(c, namespace, eventDisplayDeplName),
		)
		*receivedEvents = ev
		return ev
	}
}
