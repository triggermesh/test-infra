/*
Copyright (c) 2021 TriggerMesh Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package github

import (
	"context"
	"errors"
	"net/http"
	"os"
	"time"

	"github.com/google/go-github/v32/github"
	"golang.org/x/oauth2"

	"github.com/triggermesh/test-infra/test/e2e/framework"
)

const (
	DefaultBranch    = "main"
	DefaultRepoOwner = "triggermesh"

	commitFileName = "README.md"
)

const apiTokenEnvVar = "GITHUB_API_TOKEN"

// NewClient returns a new GitHub client.
func NewClient() *github.Client {
	return github.NewClient(oauth2.NewClient(context.Background(),
		oauth2.StaticTokenSource(&oauth2.Token{
			AccessToken: APIToken(),
		}),
	))
}

// APIToken returns a GitHub API token read from the environment.
func APIToken() string {
	return os.Getenv(apiTokenEnvVar)
}

// CreateRepository creates a GitHub repository named after the given
// framework.Framework with an initialized default branch.
func CreateRepository(client *github.Client, f *framework.Framework) *github.Repository {
	repo := &github.Repository{
		Name:         &f.UniqueName,
		Description:  github.String("Generated by the TriggerMesh e2e test suite"),
		Private:      github.Bool(true),
		MasterBranch: github.String(DefaultBranch),
	}

	var err error

	repo, _, err = client.Repositories.Create(context.Background(), DefaultRepoOwner, repo)
	if err != nil {
		framework.FailfWithOffset(2, "Failed to create GitHub repository: %s", err)
	}

	// initializes the default branch
	_ = CreateCommit(client, *repo.Owner.Login, *repo.Name)

	return repo
}

// DeleteRepository deletes a GitHub repository by owner and name.
func DeleteRepository(client *github.Client, owner, name string) {
	if _, err := client.Repositories.Delete(context.Background(), DefaultRepoOwner, name); err != nil {
		framework.FailfWithOffset(2, "Failed to create GitHub repository: %s", err)
	}
}

// CreateCommit creates a Git commit on the default branch in the repository
// with the given owner and name.
func CreateCommit(client *github.Client, owner, repoName string) *github.Commit {
	commitFile := &github.RepositoryContentFileOptions{
		Content: []byte("File updated at " + time.Now().Format(time.RFC3339Nano)),
		Message: github.String("Create file " + commitFileName),
		Branch:  github.String(DefaultBranch),

		Author: &github.CommitAuthor{
			Name:  github.String("TriggerMesh e2e"),
			Email: github.String("dev@triggermesh.com"),
		},
	}

	var resp *github.RepositoryContentResponse

	ctx := context.Background()

	file, _, _, err := client.Repositories.GetContents(ctx, owner, repoName, commitFileName,
		&github.RepositoryContentGetOptions{Ref: *commitFile.Branch})

	switch {
	case isFileNotFound(err):
		resp, _, err = client.Repositories.CreateFile(ctx, owner, repoName, commitFileName, commitFile)
		if err != nil {
			framework.FailfWithOffset(2, "Failed to create file: %s", err)
		}

	case err != nil:
		framework.FailfWithOffset(2, "Failed to get details of file: %s", err)

	default:
		commitFile.SHA = file.SHA
		commitFile.Message = github.String("Update file " + commitFileName)

		resp, _, err = client.Repositories.UpdateFile(ctx, owner, repoName, commitFileName, commitFile)
		if err != nil {
			framework.FailfWithOffset(2, "Failed to update file: %s", err)
		}
	}

	return &resp.Commit
}

// isFileNotFound returns whether the given error indicates that a file was not
// found in a Git repository.
func isFileNotFound(err error) bool {
	if ghErr := (&github.ErrorResponse{}); errors.As(err, &ghErr) {
		return ghErr.Response.StatusCode == http.StatusNotFound
	}
	return false
}
